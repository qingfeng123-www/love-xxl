<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>开心消消乐 - 终极修复版</title>
    <style>
        /* 内联样式确保不依赖外部CSS文件 */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Microsoft YaHei', Arial, sans-serif;
            background: url('image.jpg') center center / cover no-repeat fixed;
            min-height: 100vh;
            color: #333;
            overflow-x: hidden;
            position: relative;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            position: relative;
        }

        .screen {
            position: relative;
            width: 100%;
            max-width: 980px;
            margin: 0 auto;
            padding: 20px;
            border-radius: 20px;
            /* 移除背景图片，仅保留模糊和阴影 */
            backdrop-filter: blur(10px);
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            transition: all 0.3s ease;
        }

        .screen.hidden {
            display: none;
        }

        .game-title {
            font-size: 3em;
            font-weight: bold;
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4, #45b7d1, #96ceb4);
            background-size: 400% 400%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: gradientShift 3s ease-in-out infinite;
            margin-bottom: 30px;
            text-align: center;
        }

        @keyframes gradientShift {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        .btn {
            padding: 15px 30px;
            border: none;
            border-radius: 50px;
            font-size: 1.2em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin: 10px;
            display: inline-block;
        }

        .btn-primary {
            background: linear-gradient(45deg, #ff6b6b, #ee5a6f);
            color: white;
            box-shadow: 0 8px 20px rgba(255, 107, 107, 0.4);
        }

        .btn-primary:hover {
            transform: translateY(-3px);
            box-shadow: 0 12px 25px rgba(255, 107, 107, 0.6);
        }

        .btn-secondary {
            background: linear-gradient(45deg, #4ecdc4, #44a08d);
            color: white;
            box-shadow: 0 8px 20px rgba(78, 205, 196, 0.4);
        }

        .btn-secondary:hover {
            transform: translateY(-3px);
            box-shadow: 0 12px 25px rgba(78, 205, 196, 0.6);
        }

        .menu-buttons {
            display: flex;
            flex-direction: column;
            gap: 20px;
            max-width: 300px;
            margin: 0 auto;
            text-align: center;
        }

        .game-screen {
            display: flex;
            gap: 20px;
            align-items: flex-start;
            min-height: 960px;
        }

        .game-area {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
            height: 960px;
        }

        .game-canvas {
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            background: #fff;
            border: 3px solid #fff;
            width: 640px;
            height: 960px;
        }

        .game-info {
            min-width: 250px;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.1);
            height: 960px;
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
        }

        .info-section {
            margin-bottom: 20px;
        }
        
        .info-section:last-child {
            margin-bottom: 0;
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        .info-section h3 {
            color: #333;
            margin-bottom: 10px;
            font-size: 1.3em;
            border-bottom: 2px solid #007bff;
            padding-bottom: 5px;
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            padding: 8px 12px;
            background: rgba(0, 123, 255, 0.1);
            border-radius: 8px;
        }

        .stat-value {
            font-weight: bold;
            color: #007bff;
            font-size: 1.1em;
        }

        .level-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(60px, 1fr));
            gap: 10px;
            max-height: 600px;
            overflow-y: auto;
            padding: 20px;
            border-radius: 15px;
            background: rgba(255, 255, 255, 0.5);
        }

        .level-btn {
            aspect-ratio: 1;
            border: none;
            border-radius: 15px;
            font-size: 1em;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            background: linear-gradient(45deg, #f8f9fa, #e9ecef);
            color: #495057;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            position: relative;
        }

        .level-btn:hover {
            transform: scale(1.1);
            background: linear-gradient(45deg, #007bff, #0056b3);
            color: white;
        }

        .level-btn.completed {
            background: linear-gradient(45deg, #28a745, #20c997);
            color: white;
            box-shadow: 0 4px 12px rgba(40, 167, 69, 0.4);
        }

        .level-btn.completed:hover {
            background: linear-gradient(45deg, #1e7e34, #17a2b8);
            transform: scale(1.1);
        }

        .level-btn.completed::after {
            content: '✓';
            position: absolute;
            top: 2px;
            right: 2px;
            font-size: 0.8em;
            color: #fff;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 50%;
            width: 16px;
            height: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .error-popup {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 0, 0, 0.9);
            color: white;
            padding: 20px;
            border-radius: 10px;
            z-index: 10000;
            text-align: center;
            font-size: 18px;
            max-width: 400px;
        }

        .loading {
            text-align: center;
            padding: 20px;
            font-size: 1.5em;
            color: #666;
        }

        .debug-info {
            position: fixed;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 10px;
            border-radius: 5px;
            font-size: 12px;
            z-index: 9999;
            max-width: 300px;
        }

        /* 浮动提示与层 */
        .tip-layer{position:absolute;left:0;top:0;width:640px;height:960px;pointer-events:none;}
        .floating-tip{position:absolute;font-weight:bold;font-size:20px;color:#fff;text-shadow:0 0 8px #000, 0 0 12px #000;opacity:0;animation:tipFloat 1.5s ease-out forwards;z-index:100;}
        @keyframes tipFloat{0%{transform:translate(-50%,0) scale(0.8);opacity:0;}15%{opacity:1;transform:translate(-50%,0) scale(1.2);}80%{opacity:1;transform:translate(-50%,-40px) scale(1.1);}100%{transform:translate(-50%,-80px) scale(1.3);opacity:0;}}

        /* 音频解锁按钮动画 */
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        @keyframes glow {
            0%, 100% { box-shadow: 0 0 5px #2196F3; }
            50% { box-shadow: 0 0 20px #2196F3, 0 0 30px #2196F3; }
        }

        .tool-bar{margin-top:10px;display:flex;flex-wrap:wrap;gap:6px;justify-content:center;}
        /* 新的竖直排列按钮组样式 */
        .control-buttons {
            display: flex;
            flex-direction: column;
            height: 100%;
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            flex: 1;
        }
        
        .control-btn-group {
            width: 100%;
            height: 100%; /* 确保占据所有可用空间 */
            display: flex;
            flex-direction: column;
            justify-content: space-between; /* 按钮间均匀分布 */
            align-items: center;
            padding: 0;
            gap: 15px; /* 按钮间的间距 */
        }
        
        .control-buttons .btn {
            width: 100%;
            max-width: 240px;
            min-height: 44px;
            font-size: 1.18rem;
            border-radius: 28px;
            border: none;
            background: linear-gradient(90deg, #ff7e7e 0%, #6ee7b7 100%);
            color: #fff;
            box-shadow: 0 3px 12px rgba(0,0,0,0.09);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 0 auto; /* 移除垂直方向的外边距 */
            transition: background 0.3s, color 0.3s, opacity 0.3s;
            user-select: none;
        }
        
        .control-buttons .btn.orange-toggle {
            background: linear-gradient(90deg, #ff9800 0%, #ff7e7e 100%) !important;
            color: #fff3e0 !important;
            box-shadow: 0 2px 12px rgba(255,152,0,0.18) !important;
        }

        @media (max-width: 768px) {
            .game-screen {
                flex-direction: column;
            }
            .game-info {
                min-width: unset;
                width: 100%;
                order: -1;
            }
            .level-grid {
                grid-template-columns: repeat(auto-fill, minmax(50px, 1fr));
            }
            .control-buttons {
                width: 100%;
                height: auto;
            }
            .control-btn-group {
                gap: 12px;
            }
            .control-buttons .btn {
                width: 100%;
                min-width: 120px;
                min-height: 38px;
            }
        }
    </style>
</head>
<body>
    <div id="debugInfo" class="debug-info">正在加载游戏...</div>

    <div class="container">
        <!-- 主菜单界面 -->
        <div id="mainMenu" class="screen">
            <h1 class="game-title">🎮 开心消消乐</h1>
            <p style="text-align: center; font-size: 1.2em; color: #666; margin-bottom: 30px;">
                经典三消游戏，100个关卡等你挑战！
            </p>
            <div class="menu-buttons">
                <button id="startGameBtn" class="btn btn-primary">
                    🚀 开始游戏
                </button>
                <button id="levelSelectBtn" class="btn btn-secondary">
                    🎯 选择关卡
                </button>
                <button id="freePlayBtn" class="btn btn-secondary">
                    ♾️ 自由模式
                </button>
            </div>
        </div>

        <!-- 关卡选择界面 -->
        <div id="levelSelect" class="screen hidden">
            <h2 style="text-align: center; margin-bottom: 20px;">🎯 选择关卡</h2>
            <div id="levelGrid" class="level-grid"></div>
            <div style="text-align: center; margin-top: 20px;">
                <button id="backToMenuBtn" class="btn btn-secondary">
                    🏠 返回主菜单
                </button>
            </div>
        </div>

        <!-- 游戏界面 -->
        <div id="gameScreen" class="screen game-screen hidden">
            <!-- 游戏信息面板 -->
            <div class="game-info">
                <div class="info-section">
                    <h3>📊 游戏状态</h3>
                    <div class="stat-item">
                        <span>关卡</span>
                        <span id="currentLevel" class="stat-value">1</span>
                    </div>
                    <div class="stat-item">
                        <span>分数</span>
                        <span id="score" class="stat-value">0</span>
                    </div>
                    <div class="stat-item">
                        <span>剩余步数</span>
                        <span id="moves" class="stat-value">30</span>
                    </div>
                    <div class="stat-item">
                        <span>连锁</span>
                        <span id="chainInfo" class="stat-value">-</span>
                    </div>
                </div>

                <div class="info-section">
                    <h3>🎯 目标</h3>
                    <div id="objective">达到 2000 分</div>
                </div>

                <div class="info-section" style="flex: 1; display: flex; flex-direction: column; padding: 0;">
                    <h3 style="margin-bottom: 16px;">🎮 控制</h3>
                    <div class="control-buttons">
                        <div class="control-btn-group">
                            <button id="restartBtn" class="btn btn-primary">🔄 重启</button>
                            <button id="backToLevelSelectBtn" class="btn btn-secondary">🏠 返回</button>
                            <button id="muteBtn" class="btn btn-secondary">🔊 静音</button>
                            <button id="toolShuffle" class="btn btn-secondary">🌀 洗牌</button>
                            <button id="toolColorBomb" class="btn btn-secondary">🌈 变彩虹</button>
                            <button id="addMovesBtn" class="btn btn-secondary add-step-btn">➕ 加步数</button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- 游戏区域 -->
            <div class="game-area">
                <canvas id="gameCanvas" class="game-canvas" width="640" height="960"></canvas>
                <div id="tipLayer" class="tip-layer"></div>
            </div>
        </div>
    </div>

    <!-- 音频元素: 移除loop属性，改为播放列表顺序播放 -->
    <audio id="bgMusic" src="data:audio/mp3;base64,//uQxAAAAAAAAAAAAAAAAAAAAAAAWGluZwAAAA8AAAACAAACcQCA//////////////////////////////////////////8AAAAALGFuYwAAAA8AAAACAAACcQCA//////////////////////////////////////////8AAAAA" preload="auto" playsinline></audio>
    <audio id="popSound" src="data:audio/mp3;base64,//uQxAAAAAAAAAAAAAAAAAAAAAAAWGluZwAAAA8AAAACAAACcQCA//////////////////////////////////////////8AAAAALGFuYwAAAA8AAAACAAACcQCA//////////////////////////////////////////8AAAAA" preload="auto" playsinline></audio>
    <audio id="comboSound" src="data:audio/mp3;base64,//uQxAAAAAAAAAAAAAAAAAAAAAAAWGluZwAAAA8AAAACAAACcQCA//////////////////////////////////////////8AAAAALGFuYwAAAA8AAAACAAACcQCA//////////////////////////////////////////8AAAAA" preload="auto" playsinline></audio>
    <audio id="winSound" src="data:audio/mp3;base64,//uQxAAAAAAAAAAAAAAAAAAAAAAAWGluZwAAAA8AAAACAAACcQCA//////////////////////////////////////////8AAAAALGFuYwAAAA8AAAACAAACcQCA//////////////////////////////////////////8AAAAA" preload="auto" playsinline></audio>
    <audio id="loseSound" src="data:audio/mp3;base64,//uQxAAAAAAAAAAAAAAAAAAAAAAAWGluZwAAAA8AAAACAAACcQCA//////////////////////////////////////////8AAAAALGFuYwAAAA8AAAACAAACcQCA//////////////////////////////////////////8AAAAA" preload="auto" playsinline></audio>

    <script>
    // 按钮点击高亮（变色）效果，兼容移动端
    document.addEventListener('DOMContentLoaded', function() {
        // 仅除返回、重启、洗牌外的按钮点击变橙色
        var excludeIds = ['restartBtn', 'backToLevelSelectBtn', 'toolShuffle'];
        document.querySelectorAll('.control-buttons .btn').forEach(function(btn){
            if (excludeIds.includes(btn.id)) return;
            btn.addEventListener('click', function(e){
                document.querySelectorAll('.control-buttons .btn').forEach(function(otherBtn){
                    if(otherBtn !== btn && !excludeIds.includes(otherBtn.id)) {
                        otherBtn.classList.remove('orange-toggle');
                    }
                });
                btn.classList.toggle('orange-toggle');
            });
        });
    });
    // ================== 基础工具与全局 ==================
    let GameEngine = null;

    if (!CanvasRenderingContext2D.prototype.roundRect) {
        CanvasRenderingContext2D.prototype.roundRect = function(x, y, w, h, r){
            r=Math.min(r, w/2, h/2);this.beginPath();this.moveTo(x+r,y);this.lineTo(x+w-r,y);this.arcTo(x+w,y,x+w,y+r,r);this.lineTo(x+w,y+h-r);this.arcTo(x+w,y+h,x+w-r,y+h,r);this.lineTo(x+r,y+h);this.arcTo(x,y+h,x,y+h-r,r);this.lineTo(x,y+r);this.arcTo(x,y,x+r,y,r);this.closePath();
        };
    }
    function debugLog(msg){const d=document.getElementById('debugInfo'); if(d){d.innerHTML='['+new Date().toLocaleTimeString()+'] '+msg;} console.log('[GAME]',msg);} 
    function showError(message){ alert(message); }

    // ================== UI 控制 ==================
    const SimpleUI={currentScreen:'mainMenu',showScreen(name){['mainMenu','levelSelect','gameScreen'].forEach(id=>{const el=document.getElementById(id); if(el) el.classList.add('hidden');}); const t=document.getElementById(name); if(t){t.classList.remove('hidden'); this.currentScreen=name; if(name==='levelSelect') this.createLevelGrid(); if(name==='gameScreen') this.initGameScreen();}},createLevelGrid(){const grid=document.getElementById('levelGrid'); if(!grid) return; grid.innerHTML=''; for(let i=1;i<=100;i++){const btn=document.createElement('button'); btn.className='level-btn'; btn.textContent=i; btn.onclick=()=>this.startLevel(i); if(GameEngine){ const completed=GameEngine.getCompletedLevels(); if(completed[i]) btn.classList.add('completed'); } grid.appendChild(btn);} },startLevel(id){this.showScreen('gameScreen'); if(GameEngine) GameEngine.startLevel(id);},initGameScreen(){setTimeout(()=>{ if(GameEngine){ GameEngine.initCanvas(); GameEngine.render();}},80);}};

    // ================== 游戏引擎（单一有效版本） ==================
    class SimpleGameEngine {
        constructor(){
            // 尺寸：8列12行
            this.gridCols=8; this.gridRows=12; // 旧代码里使用 gridSize 的地方需要兼容列数，因此：
            this.gridSize=this.gridCols; 
            this.canvas=null; this.ctx=null; this.tileSize=80; // 640/8
            this.grid=[]; this.score=0; this.moves=0; this.baseMoves=20; this.levelId=1; this.targetScore=400; this.selectedGem=null; this.isPlaying=false; this.gemTypes=6;
            this.allColors=['#ff5722','#2196f3','#4caf50','#ffeb3b','#9c27b0','#ff9800','#00bcd4','#8bc34a','#e91e63'];
            this.gemColors=this.allColors.slice(0,this.gemTypes);
            this.animating=false; this.particles=[]; this.effects=[]; this.currentChain=0; this.currentTool=null; this.colorToolAvailable=true;
            this.unlockedLevels=this.loadUnlocked(); this.audio=this.initAudio(); this.isMuted=false; this.audioUnlocked=false; this.imageWarned=false; this.images=[];
            this.accentColors=['#ff6b6b','#4ecdc4','#45b7d1','#96ceb4','#ffa94d','#9775fa','#74c0fc','#63e6be','#f06595'];
            this.musicSources=[]; // 五首背景音乐列表
            this.currentMusicIndex=0;
            this.musicStarted=false;
            this.preloadImages();
            
            // 初始化完成后立即尝试启动音频，增加延迟确保资源加载完成
            setTimeout(() => {
                debugLog('尝试启动音频解锁...');
                this.ensureAudioUnlock();
            }, 500);
            
            setTimeout(() => {
                debugLog('尝试启动背景音乐播放列表...');
                this.startMusicPlaylist();
            }, 1000);
        }
        // ---------- 资源 ----------
        preloadImages(){this.imagesLoadedCount=0; this.imagesFailedCount=0; this.totalImages=this.allColors.length; for(let i=0;i<this.totalImages;i++){const img=new Image(); img.onload=()=>{img.loaded=true; this.imagesLoadedCount++; this.checkImageLoadComplete();}; img.onerror=()=>{img.failed=true; this.imagesFailedCount++; this.checkImageLoadComplete();}; img.src='images/gem'+i+'.png?t='+(Date.now()); this.images[i]=img;} debugLog('加载宝石图片 '+this.totalImages+' 个'); }
        checkImageLoadComplete(){ if(this.imagesLoadedCount+this.imagesFailedCount>=this.totalImages){ debugLog('图片加载完成 成功:'+this.imagesLoadedCount+' 失败:'+this.imagesFailedCount); if(this.imagesLoadedCount===0) debugLog('全部失败，使用颜色替代'); } }
        initAudio(){
            debugLog('开始初始化音频系统');
            const a={bg:document.getElementById('bgMusic'),pop:document.getElementById('popSound'),combo:document.getElementById('comboSound'),win:document.getElementById('winSound'),lose:document.getElementById('loseSound')};
            if(a.bg){a.bg.preload='auto'; a.bg.volume=0.85; a.bg.loop=false;} // loop改由播放列表控制
            ['pop','combo','lose'].forEach(k=>{if(a[k]){a[k].preload='auto'; a[k].volume=0.7;}});
            if(a.win){a.win.preload='auto'; a.win.volume=0.3;}
            
            // 初始化音乐源列表
            const basePath='audio/9439/';
            const candidates=['bg1.mp3','bg2.mp3','bg3.mp3','bg4.mp3','bg5.mp3'];
            this.musicSources=candidates.map(n=>basePath+n);
            debugLog('音乐源列表已初始化: ' + this.musicSources.join(', '));
            
            // 立即加载所有音效文件
            const soundMap={pop:'pop',combo:'combo',win:'win',lose:'lose'};
            Object.keys(soundMap).forEach(k=>{
                const el=a[k];
                if(el) {
                    el.src=basePath+soundMap[k]+'.mp3?t='+(Date.now());
                    el.load();
                    // 为音效添加错误处理
                    el.addEventListener('error', () => {
                        debugLog('音效文件加载失败: ' + k + '，使用默认音效');
                    });
                }
            });
            
            // 绑定播放结束事件 - 实现播放列表循环
            if(a.bg){
                a.bg.addEventListener('ended', () => {
                    if(this.isMuted || !this.isPlaying) {
                        debugLog('音乐结束，但游戏未在运行或已静音');
                        return;
                    }
                    // 随机选择下一首
                    this.currentMusicIndex = Math.floor(Math.random() * this.musicSources.length);
                    debugLog('音乐播放完毕，随机切换到第 ' + (this.currentMusicIndex + 1) + ' 首');
                    this.playNextMusic();
                });
                
                // 监听加载错误，自动跳到下一首
                a.bg.addEventListener('error', () => {
                    debugLog('音乐加载失败，随机跳到下一首');
                    this.currentMusicIndex = Math.floor(Math.random() * this.musicSources.length);
                    this.playNextMusic();
                });
            }
            
            debugLog('音频系统初始化完成');
            return a;
        }
        // 播放下一首音乐的方法
        playNextMusic() {
            if(!this.audio || !this.audio.bg || this.isMuted) {
                debugLog('播放条件不满足: audio=' + !!this.audio + ', bg=' + !!(this.audio && this.audio.bg) + ', muted=' + this.isMuted);
                return;
            }
            
            // 确保musicSources已初始化
            if(!this.musicSources || this.musicSources.length === 0) {
                debugLog('音乐源列表为空，重新初始化');
                const basePath = 'audio/9439/';
                const candidates = ['bg1.mp3', 'bg2.mp3', 'bg3.mp3', 'bg4.mp3', 'bg5.mp3'];
                this.musicSources = candidates.map(n => basePath + n);
                this.currentMusicIndex = 0;
            }
            
            // 确保索引有效
            if(this.currentMusicIndex >= this.musicSources.length || this.currentMusicIndex < 0) {
                this.currentMusicIndex = Math.floor(Math.random() * this.musicSources.length);
            }
            
            const bg = this.audio.bg;
            const currentSrc = this.musicSources[this.currentMusicIndex];
            
            if(!currentSrc) {
                debugLog('当前音乐源为空，索引: ' + this.currentMusicIndex + ', 列表长度: ' + this.musicSources.length);
                return;
            }
            
            debugLog('开始播放第 ' + (this.currentMusicIndex + 1) + ' 首音乐: ' + currentSrc);
            
            // 重置音频元素
            bg.pause();
            bg.currentTime = 0;
            bg.src = currentSrc + '?t=' + Date.now();
            
            // 加载并播放
            bg.load();
            
            const playWhenReady = () => {
                if(!this.isMuted && this.isPlaying) {
                    bg.volume = 0.85;
                    bg.play().catch((error) => {
                        debugLog('音乐播放失败: ' + error.message + '，随机跳到下一首');
                        // 播放失败时随机跳到下一首
                        setTimeout(() => {
                            this.currentMusicIndex = Math.floor(Math.random() * this.musicSources.length);
                            this.playNextMusic();
                        }, 500);
                    });
                }
            };
            
            // 监听加载完成事件
            bg.addEventListener('canplay', playWhenReady, { once: true });
            
            // 设置超时，防止长时间等待
            setTimeout(() => {
                if(bg.readyState >= 2) { // HAVE_CURRENT_DATA
                    playWhenReady();
                }
            }, 1000);
        }
        
        // 背景音乐加载方法，带错误处理
        loadBackgroundMusic(bgElement, sourceIndex = 0, fallbackSources = []) {
            // 移除这个方法，使用更简单的playNextMusic
            // 这个方法已被弃用
            debugLog('loadBackgroundMusic方法已弃用，使用playNextMusic替代');
        }

        startMusicPlaylist(){
            if(this.musicStarted || !this.audio || !this.audio.bg || this.isMuted) {
                debugLog('音乐播放列表启动条件不满足: started=' + this.musicStarted + ', audio=' + !!this.audio + ', bg=' + !!(this.audio && this.audio.bg) + ', muted=' + this.isMuted);
                return;
            }
            
            // 确保音乐源已初始化
            if(!this.musicSources || this.musicSources.length === 0) {
                debugLog('初始化音乐源列表');
                const basePath = 'audio/9439/';
                const candidates = ['bg1.mp3', 'bg2.mp3', 'bg3.mp3', 'bg4.mp3', 'bg5.mp3'];
                this.musicSources = candidates.map(n => basePath + n);
            }
            
            debugLog('启动音乐播放列表，共 ' + this.musicSources.length + ' 首音乐');
            // 第一首也随机
            this.currentMusicIndex = Math.floor(Math.random() * this.musicSources.length);
            this.musicStarted = true;
            this.playNextMusic();
        }
        
        attemptPlay() {
            // 这个方法已被简化，现在直接使用playNextMusic
            if(!this.musicStarted) {
                this.startMusicPlaylist();
            }
        }
        ensureMusicPlaying(){
            if(!this.audio || !this.audio.bg || this.isMuted) return;
            
            // 如果音乐暂停了，重新启动播放列表
            if(this.audio.bg.paused && this.isPlaying) {
                debugLog('检测到音乐暂停，重新启动');
                if(!this.musicStarted) {
                    this.startMusicPlaylist();
                } else {
                    this.playNextMusic();
                }
            }
        }
        play(name,vol=.6){ 
            if(this.isMuted) return; 
            
            if(name==='bg'){ 
                if(!this.musicStarted) {
                    this.startMusicPlaylist(); 
                } else {
                    this.ensureMusicPlaying();
                }
                return; 
            }
            
            const a=this.audio[name];
            if(!a) return;
            try {
                a.currentTime = 0;
                if(name==='win') {
                    a.volume = 0.3;
                } else {
                    a.volume = vol;
                }
                a.play().catch(()=>{});
            } catch(e){}
        }
        toggleMute(){ 
            this.isMuted = !this.isMuted; 
            const btn = document.getElementById('muteBtn'); 
            if(btn) btn.textContent = this.isMuted ? '🔇 解除静音' : '🔊 静音'; 
            // 只调整音量，不暂停/重播
            if(this.audio && this.audio.bg) {
                this.audio.bg.volume = this.isMuted ? 0 : 0.85;
            }
            // 其它音效也静音
            ['pop','combo','win','lose'].forEach(k => {
                if(this.audio && this.audio[k]) {
                    this.audio[k].volume = this.isMuted ? 0 : 1;
                }
            });
            debugLog(this.isMuted ? '已静音(仅音量)' : '取消静音(仅音量)');
        }
        // ---------- 存档 ----------
        loadUnlocked(){try{const d=localStorage.getItem('match3_unlocked'); if(d) return JSON.parse(d);}catch(e){} return {1:true};}
        saveUnlocked(){try{localStorage.setItem('match3_unlocked',JSON.stringify(this.unlockedLevels));}catch(e){}}
        getCompletedLevels(){try{const d=localStorage.getItem('match3_completed'); if(d) return JSON.parse(d);}catch(e){} return {};}
        saveCompletedLevel(id){try{const c=this.getCompletedLevels(); c[id]=true; localStorage.setItem('match3_completed',JSON.stringify(c));}catch(e){}}
        // ---------- 初始化画布 ----------
        initCanvas(){ if(this.canvas) return true; this.canvas=document.getElementById('gameCanvas'); if(!this.canvas) return false; this.ctx=this.canvas.getContext('2d'); this.tileSize=this.canvas.width/this.gridCols; const expectedH=this.tileSize*this.gridRows; if(this.canvas.height!==expectedH) this.canvas.height=expectedH; const tip=document.getElementById('tipLayer'); if(tip){tip.style.width=this.canvas.width+'px'; tip.style.height=this.canvas.height+'px';} this.canvas.onclick=e=>this.handleClick(e); requestAnimationFrame(()=>this.render()); return true; }
        setThemeColor(id){
            // 保持背景为image.jpg，不做任何更改
        }
        levelConfig(id){const target=400+(id-1)*120+Math.floor((id-1)/10)*200; const moves=Math.max(15,this.baseMoves-Math.floor((id-1)/5)); return {target,moves}; }
        startLevel(id){ if(!this.initCanvas()) return; if(id!==0 && !this.unlockedLevels[id]){alert('未解锁'); return;} this.levelId=id===0?'自由':id; const cfg=id===0?{target:0,moves:9999}:this.levelConfig(id); if(id!==0){ this.gemTypes=Math.min(3+Math.floor((id-1)/8),this.allColors.length); this.gemColors=this.allColors.slice(0,this.gemTypes);} this.targetScore=cfg.target; this.moves=cfg.moves; this.score=0; this.selectedGem=null; this.isPlaying=true; this.currentChain=0; this.effects=[]; this.currentTool=null; this.colorToolAvailable=true; const btn=document.getElementById('toolColorBomb'); if(btn){btn.disabled=false; btn.style.opacity='1'; btn.classList.remove('active');} this.generateInitialGrid(); this.placeObstacles(); this.updateObjectiveUI(); this.updateUI(); this.setThemeColor(id===0?1:id); 
        
        // 强制启动音乐（如果还没有启动的话）
        if(!this.musicStarted) {
            debugLog('关卡开始时强制启动音乐');
            this.startMusicPlaylist();
        } else {
            this.ensureMusicPlaying();
        }
        
        this.ensureAudioUnlock(); }
        updateObjectiveUI(){const l=document.getElementById('currentLevel'); const o=document.getElementById('objective'); if(l) l.textContent=this.levelId; if(o) o.textContent=this.levelId==='自由'? '自由模式：无限分数':'目标分数: '+this.targetScore;}
        // ---------- 棋盘生成 ----------
        generateInitialGrid(){this.grid=[]; for(let y=0;y<this.gridRows;y++){this.grid[y]=[]; for(let x=0;x<this.gridCols;x++){let t; do{t=Math.floor(Math.random()*this.gemTypes);}while(this.causesImmediateMatch(x,y,t)); this.grid[y][x]={type:t,x,y,special:null};}}}
        causesImmediateMatch(x,y,t){ if(x>=2 && this.grid[y][x-1] && this.grid[y][x-2] && this.grid[y][x-1].type===t && this.grid[y][x-2].type===t) return true; if(y>=2 && this.grid[y-1] && this.grid[y-2] && this.grid[y-1][x] && this.grid[y-2][x].type===t && this.grid[y-1][x].type===t) return true; return false; }
        placeObstacles(){ if(this.levelId==='自由') return; const iceProb=Math.min(0.03+(this.levelId-1)*0.003,0.25); for(let y=0;y<this.gridRows;y++) for(let x=0;x<this.gridCols;x++){ if(Math.random()<iceProb){ const g=this.grid[y][x]; if(g) g.locked=1; }} }
        // ---------- 输入 ----------
        handleClick(e){ if(!this.isPlaying||this.animating) return; const r=this.canvas.getBoundingClientRect(); const x=Math.floor((e.clientX-r.left)/this.tileSize); const y=Math.floor((e.clientY-r.top)/this.tileSize); if(x<0||x>=this.gridCols||y<0||y>=this.gridRows) return; if(this.currentTool){ this.useTool(x,y); return;} const cell=this.grid[y][x]; if(cell&&cell.locked){ this.showTip('🔒 被冰封',(x+0.5)*this.tileSize,(y+0.5)*this.tileSize); return;} if(!this.selectedGem){ this.selectedGem={x,y}; } else { if(this.selectedGem.x===x&&this.selectedGem.y===y) this.selectedGem=null; else if(this.isAdjacent(this.selectedGem,{x,y})){ this.attemptSwap(this.selectedGem,{x,y}); this.selectedGem=null;} else this.selectedGem={x,y}; } }
        // ---------- 道具 ----------
        activateTool(n){ if(this.animating) return; this.currentTool=this.currentTool===n?null:n; this.highlightTools(); }
        highlightTools(){const map={toolShuffle:'shuffle',toolColorBomb:'color'}; Object.keys(map).forEach(id=>{const el=document.getElementById(id); if(!el) return; if(this.currentTool===map[id]) el.classList.add('active'); else el.classList.remove('active');});}
        useTool(x,y){const t=this.currentTool; const cell=this.grid[y][x]; if(t==='color'){ if(!this.colorToolAvailable){ this.showTip('🚫 已使用',(x+0.5)*this.tileSize,(y+0.5)*this.tileSize); } else if(cell && !cell.obstacle){ cell.special='color'; this.colorToolAvailable=false; const b=document.getElementById('toolColorBomb'); if(b){b.disabled=true; b.style.opacity='.45'; b.classList.remove('active');} this.showTip('🌈',(x+0.5)*this.tileSize,(y+0.5)*this.tileSize);} } else if(t==='shuffle'){ if(this.shuffleBoard()) this.showTip('🔁 已洗牌',this.canvas.width/2,this.canvas.height/2);} this.currentTool=null; this.highlightTools(); }
        // ---------- 核心逻辑 ----------
        isAdjacent(a,b){return Math.abs(a.x-b.x)+Math.abs(a.y-b.y)===1;}
        swapRaw(a,b){const g1=this.grid[a.y][a.x]; const g2=this.grid[b.y][b.x]; this.grid[a.y][a.x]=g2; if(g2){g2.x=a.x; g2.y=a.y;} this.grid[b.y][b.x]=g1; if(g1){g1.x=b.x; g1.y=b.y;}}
        attemptSwap(a,b){const g1=this.grid[a.y][a.x]; const g2=this.grid[b.y][b.x]; if((g1&&g1.locked)||(g2&&g2.locked)){ this.showTip('🔒 无法移动',(b.x+0.5)*this.tileSize,(b.y+0.5)*this.tileSize); return;} this.swapRaw(a,b); const s1=this.grid[a.y][a.x]; const s2=this.grid[b.y][b.x]; const special=s1.special||s2.special; let groups=this.findMatches(); if(groups.length===0 && special){ this.moves--; this.triggerSpecialSwap(s1,s2); this.updateUI(); return;} if(groups.length===0){ this.swapRaw(a,b); this.play('combo',0.2);} else { this.moves--; this.processMatches(groups,1);} this.updateUI(); }
        findMatches(){const groups=[]; // 原有水平 / 垂直
            for(let y=0;y<this.gridRows;y++){ let run=[]; for(let x=0;x<this.gridCols;x++){const c=this.grid[y][x]; if(!c||c.obstacle==='stone'){ if(run.length>=3) groups.push({cells:run.slice(),orientation:'h'}); run=[]; continue;} if(run.length===0||c.type===run[run.length-1].type) run.push(c); else { if(run.length>=3) groups.push({cells:run.slice(),orientation:'h'}); run=[c]; }} if(run.length>=3) groups.push({cells:run.slice(),orientation:'h'});} for(let x=0;x<this.gridCols;x++){ let run=[]; for(let y=0;y<this.gridRows;y++){const c=this.grid[y][x]; if(!c||c.obstacle==='stone'){ if(run.length>=3) groups.push({cells:run.slice(),orientation:'v'}); run=[]; continue;} if(run.length===0||c.type===run[run.length-1].type) run.push(c); else { if(run.length>=3) groups.push({cells:run.slice(),orientation:'v'}); run=[c]; }} if(run.length>=3) groups.push({cells:run.slice(),orientation:'v'});} return groups; }
        detectTShapes(){ const tShapes=[]; for(let y=0;y<this.gridRows;y++){ for(let x=0;x<this.gridCols;x++){ const center=this.grid[y][x]; if(!center) continue; const type=center.type; const inside=(xx,yy)=>yy>=0&&yy<this.gridRows&&xx>=0&&xx<this.gridCols&&this.grid[yy][xx]&&this.grid[yy][xx].type===type; // 四种T
                const cond1=inside(x-1,y)&&inside(x+1,y)&&inside(x,y+1)&&inside(x,y+2)&&inside(x,y); // ┬ (竖在下)
                const cond2=inside(x-1,y)&&inside(x+1,y)&&inside(x,y-1)&&inside(x,y-2)&&inside(x,y); // ┴ (竖在上)
                const cond3=inside(x,y-1)&&inside(x,y+1)&&inside(x-1,y)&&inside(x-2,y)&&inside(x,y); // ┤ (横在左)
                const cond4=inside(x,y-1)&&inside(x,y+1)&&inside(x+1,y)&&inside(x+2,y)&&inside(x,y); // ├ (横在右)
                if(cond1||cond2||cond3||cond4){
                    // 收集所有组成格子（至少5个，可能 7 个，如交叉时）
                    const cells=new Set();
                    cells.add(x+','+y);
                    if(cond1||cond2){ cells.add((x-1)+','+y); cells.add((x+1)+','+y); }
                    if(cond3||cond4){ cells.add(x+','+(y-1)); cells.add(x+','+(y+1)); }
                    if(cond1){ cells.add(x+','+(y+1)); cells.add(x+','+(y+2)); }
                    if(cond2){ cells.add(x+','+(y-1)); cells.add(x+','+(y-2)); }
                    if(cond3){ cells.add((x-1)+','+y); cells.add((x-2)+','+y); }
                    if(cond4){ cells.add((x+1)+','+y); cells.add((x+2)+','+y); }
                    const cellArr=[...cells].map(s=>{const [xx,yy]=s.split(',').map(Number); return {x:xx,y:yy};});
                    // 避免重复：检查是否已有同中心
                    if(!tShapes.find(t=>t.center.x===x&&t.center.y===y)) tShapes.push({center:{x,y},cells:cellArr,type});
                }
            }} return tShapes; }
        processMatches(groups,chain){ if(groups.length===0) return; this.animating=true; const toRemove=new Set(); const specials=[]; const lineActivations=[]; let baseScore=0; // T 形检测
            const tShapes=this.detectTShapes(); const bombCenters=[];
            groups.forEach(g=>{const len=g.cells.length; g.cells.forEach(c=>{toRemove.add(c.y+','+c.x); if(c.special==='lineH'||c.special==='lineV'||c.special==='bomb') lineActivations.push(c);}); if(len===3) baseScore+=60; else if(len===4){ baseScore+=120; const p=g.cells[1]; specials.push({x:p.x,y:p.y,type:p.type,special:g.orientation==='h'?'lineH':'lineV'});} else if(len>=5){ baseScore+=200+(len-5)*40; const p=g.cells[Math.floor(len/2)]; specials.push({x:p.x,y:p.y,type:p.type,special:'color'});} });
            // 处理 T 形：覆盖中心特殊，得分额外奖励
            tShapes.forEach(t=>{ t.cells.forEach(c=>toRemove.add(c.y+','+c.x)); bombCenters.push(t.center); baseScore+=240; });
            // 移除与炸弹中心冲突的其它特殊（优先炸弹）
            for(let i=specials.length-1;i>=0;i--){ if(bombCenters.find(b=>b.x===specials[i].x&&b.y===specials[i].y)) specials.splice(i,1); }
            lineActivations.forEach(c=>{ if(c.special==='lineH'){ for(let x=0;x<this.gridCols;x++) toRemove.add(c.y+','+x); this.addLineEffect('h',c.y,'lineClear'); } else if(c.special==='lineV'){ for(let y=0;y<this.gridRows;y++) toRemove.add(y+','+c.x); this.addLineEffect('v',c.x,'lineClear'); } else if(c.special==='bomb'){ // 炸弹扩散
                    for(let dy=-1;dy<=1;dy++) for(let dx=-1;dx<=1;dx++){ const nx=c.x+dx, ny=c.y+dy; if(nx>=0&&nx<this.gridCols&&ny>=0&&ny<this.gridRows) toRemove.add(ny+','+nx); } this.addExplosionEffect(c.x,c.y); }
            });
            // 如果 toRemove 中含有现有炸弹，使其爆炸范围扩展
            const extraBombs=[]; toRemove.forEach(k=>{const [y,x]=k.split(',').map(Number); const cell=this.grid[y]&&this.grid[y][x]; if(cell&&cell.special==='bomb'){ extraBombs.push({x,y}); }});
            extraBombs.forEach(b=>{ for(let dy=-1;dy<=1;dy++) for(let dx=-1;dx<=1;dx++){ const nx=b.x+dx, ny=b.y+dy; if(nx>=0&&nx<this.gridCols&&ny>=0&&ny<this.gridRows) toRemove.add(ny+','+nx); } this.addExplosionEffect(b.x,b.y); });
            const gained=Math.floor((baseScore+toRemove.size*10)*(1+(chain-1)*0.5)); this.score+=gained; this.currentChain=chain; this.play(chain>1?'combo':'pop', chain>1?0.9:0.6); toRemove.forEach(k=>{const [y,x]=k.split(',').map(Number); const cell=this.grid[y][x]; if(cell) this.spawnParticles(x,y,cell); this.grid[y][x]=null;});
            specials.forEach(sp=>{ this.grid[sp.y][sp.x]={type:sp.type,x:sp.x,y:sp.y,special:sp.special};});
            bombCenters.forEach(b=>{ this.grid[b.y][b.x]={type:this.grid[b.y][b.x]?this.grid[b.y][b.x].type:Math.floor(Math.random()*this.gemTypes),x:b.x,y:b.y,special:'bomb'}; });
            this.showTip('+'+gained+(chain>1?' 连锁x'+(1+(chain-1)*0.5).toFixed(1):''),this.canvas.width/2, this.canvas.height/2 - chain*26); this.updateUI(); this.cascade(chain); }
        triggerSpecialSwap(g1,g2){ const isLine=g=>g&&(g.special==='lineH'||g.special==='lineV');
            if(g1.special==='bomb'||g2.special==='bomb'){ const b=g1.special==='bomb'?g1:g2; this.explodeAt(b.x,b.y); this.cascade(1); return; }
            if(g1.special==='color'&&g2.special==='color'){ const cells=[]; for(let y=0;y<this.gridRows;y++) for(let x=0;x<this.gridCols;x++) cells.push({x,y}); this.clearCells(cells,'双彩虹',80); this.showTip('🌈🌈',this.canvas.width/2,this.canvas.height/2); this.cascade(1); return; }
            if(g1.special==='color'||g2.special==='color'){ const target=g1.special==='color'?g2:g1; const cells=[]; for(let y=0;y<this.gridRows;y++) for(let x=0;x<this.gridCols;x++) if(this.grid[y][x].type===target.type) cells.push({x,y}); this.clearCells(cells,'彩虹清色',70); this.showTip('🌈',this.canvas.width/2,this.canvas.height/2); this.cascade(1); return; }
            if(isLine(g1)&&isLine(g2)){ const rows=new Set([g1.y,g2.y]); const cols=new Set([g1.x,g2.x]); const cells=[]; rows.forEach(r=>{for(let x=0;x<this.gridCols;x++) cells.push({x,y:r});}); cols.forEach(c=>{for(let y=0;y<this.gridRows;y++) cells.push({x:c,y});}); this.clearCells(cells,'双线',65); this.addLineEffect('h',g1.y,'lineClear'); this.addLineEffect('v',g1.x,'lineClear'); this.showTip('⚡⚡',this.canvas.width/2,this.canvas.height/2); this.cascade(1); return; }
        }
        explodeAt(x,y){ const cells=[]; for(let dy=-1;dy<=1;dy++) for(let dx=-1;dx<=1;dx++){ const nx=x+dx, ny=y+dy; if(nx>=0&&nx<this.gridCols&&ny>=0&&ny<this.gridRows) cells.push({x:nx,y:ny}); } this.clearCells(cells,'炸弹',60); this.addExplosionEffect(x,y); }
        addExplosionEffect(x,y){ this.effects.push({kind:'explosion',x,y,progress:0}); }
        // ---------- 视觉 ----------
        spawnParticles(x,y,gem){ const px=x*this.tileSize+this.tileSize/2; const py=y*this.tileSize+this.tileSize/2; const color=this.gemColors[gem.type%this.gemColors.length]; for(let i=0;i<14;i++){const ang=Math.random()*Math.PI*2; const sp=2+Math.random()*4; this.particles.push({x:px,y:py,vx:Math.cos(ang)*sp,vy:Math.sin(ang)*sp,life:50+Math.random()*20,maxLife:50+Math.random()*20,size:2+Math.random()*3,color,rotation:Math.random()*Math.PI*2,rotationSpeed:(Math.random()-0.5)*0.2,special:gem.special?true:false});} }
        updateParticles(){ this.particles=this.particles.filter(p=>p.life>0); this.particles.forEach(p=>{ p.x+=p.vx; p.y+=p.vy; p.vy+=0.12; p.vx*=0.985; p.life--; p.rotation+=p.rotationSpeed;}); this.effects=this.effects.filter(e=>e.progress<1); this.effects.forEach(e=>{ e.progress+=0.05;}); }
        drawGem(x,y,type){ const gem=this.grid[y][x]; if(!gem) return; const img=this.images[type%this.images.length]; const cx=x*this.tileSize; const cy=y*this.tileSize; const pad=8; const size=this.tileSize-pad*2; const r=size*0.2; const usable=img && img.complete && !img.failed && img.naturalWidth>0; this.ctx.save(); this.ctx.beginPath(); this.ctx.roundRect(cx+pad,cy+pad,size,size,r); this.ctx.clip(); if(usable){ try{ this.ctx.drawImage(img,cx+pad,cy+pad,size,size);}catch(e){ this.drawFallbackGem(cx,cy,type,gem);} } else { this.drawFallbackGem(cx,cy,type,gem,true);} this.ctx.restore(); this.drawSpecialMarkers(gem,cx,cy); if(gem.locked) this.drawIce(x,y); }
        lightenColor(col,f){const h=col.replace('#',''); const r=parseInt(h.substr(0,2),16),g=parseInt(h.substr(2,2),16),b=parseInt(h.substr(4,2),16); const nr=Math.min(255, r+(255-r)*f), ng=Math.min(255, g+(255-g)*f), nb=Math.min(255, b+(255-b)*f); return 'rgb('+nr+','+ng+','+nb+')'; }
        drawFallbackGem(cx,cy,type,gem,isPlain){const pad=8; const size=this.tileSize-pad*2; const r=size*0.25; const cX=cx+this.tileSize/2, cY=cy+this.tileSize/2; this.ctx.beginPath(); this.ctx.roundRect(cx+pad,cy+pad,size,size,r); const base=this.gemColors[type%this.gemColors.length]; const grad=this.ctx.createRadialGradient(cX,cY,0,cX,cY,size/2); grad.addColorStop(0,this.lightenColor(base,.35)); grad.addColorStop(1,base); this.ctx.fillStyle=grad; this.ctx.fill(); this.ctx.strokeStyle='#fff'; this.ctx.lineWidth=3; this.ctx.stroke(); if(isPlain && !this.imageWarned){ this.imageWarned=true; this.showTip('使用颜色替代',this.canvas.width/2,150);} }
        drawSpecialMarkers(gem,cx,cy){ if(!gem.special) return; const centerX=cx+this.tileSize/2, centerY=cy+this.tileSize/2; this.ctx.save(); if(gem.special==='lineH'||gem.special==='lineV'){ this.ctx.strokeStyle='#FFD700'; this.ctx.lineWidth=6; this.ctx.shadowColor='#FFD700'; this.ctx.shadowBlur=10; if(gem.special==='lineH'){ this.ctx.beginPath(); this.ctx.moveTo(cx+this.tileSize*0.15,centerY); this.ctx.lineTo(cx+this.tileSize*0.85,centerY); this.ctx.stroke(); } else { this.ctx.beginPath(); this.ctx.moveTo(centerX,cy+this.tileSize*0.15); this.ctx.lineTo(centerX,cy+this.tileSize*0.85); this.ctx.stroke(); } } else if(gem.special==='color'){ const radius=this.tileSize*0.22; const colors=['#FF0000','#FF7F00','#FFFF00','#00FF00','#0000FF','#4B0082','#9400D3']; for(let i=0;i<7;i++){const a=i*Math.PI*2/7; this.ctx.strokeStyle=colors[i]; this.ctx.lineWidth=4; this.ctx.beginPath(); this.ctx.moveTo(centerX,centerY); this.ctx.lineTo(centerX+Math.cos(a)*radius, centerY+Math.sin(a)*radius); this.ctx.stroke(); } this.ctx.fillStyle='rgba(255,255,255,0.9)'; this.ctx.beginPath(); this.ctx.arc(centerX,centerY,radius*0.5,0,Math.PI*2); this.ctx.fill(); } else if(gem.special==='bomb'){ const r=this.tileSize*0.28; const grad=this.ctx.createRadialGradient(centerX,centerY,0,centerX,centerY,r); grad.addColorStop(0,'#fff8e1'); grad.addColorStop(0.5,'#ffca28'); grad.addColorStop(1,'#ff5722'); this.ctx.fillStyle=grad; this.ctx.beginPath(); this.ctx.arc(centerX,centerY,r,0,Math.PI*2); this.ctx.fill(); this.ctx.lineWidth=3; this.ctx.strokeStyle='#ffd54f'; this.ctx.stroke(); for(let i=0;i<6;i++){ const a=i*Math.PI/3; this.ctx.beginPath(); this.ctx.moveTo(centerX+Math.cos(a)*r*0.3, centerY+Math.sin(a)*r*0.3); this.ctx.lineTo(centerX+Math.cos(a)*r*0.95, centerY+Math.sin(a)*r*0.95); this.ctx.strokeStyle='#ffeb3b'; this.ctx.lineWidth=2; this.ctx.stroke(); } } this.ctx.restore(); }
        render(){ if(!this.ctx) return; // 恢复原有完整绘制流程 + 爆炸特效
            this.ctx.clearRect(0,0,this.canvas.width,this.canvas.height);
            // 网格
            this.ctx.strokeStyle='#2224'; this.ctx.lineWidth=1;
            for(let x=0;x<=this.gridCols;x++){ this.ctx.beginPath(); this.ctx.moveTo(x*this.tileSize,0); this.ctx.lineTo(x*this.tileSize,this.gridRows*this.tileSize); this.ctx.stroke(); }
            for(let y=0;y<=this.gridRows;y++){ this.ctx.beginPath(); this.ctx.moveTo(0,y*this.tileSize); this.ctx.lineTo(this.gridCols*this.tileSize,y*this.tileSize); this.ctx.stroke(); }
            // 宝石
            for(let y=0;y<this.gridRows;y++) for(let x=0;x<this.gridCols;x++){ const cell=this.grid[y][x]; if(!cell) continue; this.drawGem(x,y,cell.type); }
            // 选中框
            if(this.selectedGem){ this.ctx.strokeStyle='#ff0000'; this.ctx.lineWidth=3; this.ctx.strokeRect(this.selectedGem.x*this.tileSize+2,this.selectedGem.y*this.tileSize+2,this.tileSize-4,this.tileSize-4); }
            // 粒子 & 效果进度
            this.updateParticles();
            // 粒子渲染
            this.particles.forEach(p=>{ const a=p.life/p.maxLife; this.ctx.save(); this.ctx.globalAlpha=a; this.ctx.translate(p.x,p.y); this.ctx.rotate(p.rotation); this.ctx.fillStyle=p.color; this.ctx.shadowColor=p.color; this.ctx.shadowBlur=p.special?10:6; this.ctx.beginPath(); if(p.special){ for(let i=0;i<5;i++){ const ang=i*Math.PI*2/5; const xx=Math.cos(ang)*p.size; const yy=Math.sin(ang)*p.size; if(i===0) this.ctx.moveTo(xx,yy); else this.ctx.lineTo(xx,yy);} } else { this.ctx.arc(0,0,p.size,0,Math.PI*2);} this.ctx.closePath(); this.ctx.fill(); this.ctx.restore(); });
            // 特效渲染（含爆炸）
            this.effects.forEach(e=>{ const t=e.progress; this.ctx.save(); if(e.kind==='lineClear'){ const alpha=1-t; this.ctx.globalCompositeOperation='lighter'; if(e.orientation==='h'){ const y=e.index*this.tileSize; this.ctx.fillStyle='rgba(255,215,0,'+(0.4+0.3*Math.sin(t*8))+')'; this.ctx.fillRect(0,y,this.canvas.width,this.tileSize); this.ctx.fillStyle='rgba(255,255,255,'+alpha+')'; this.ctx.fillRect(0,y+this.tileSize*0.4,this.canvas.width,this.tileSize*0.2);} else { const x=e.index*this.tileSize; this.ctx.fillStyle='rgba(255,215,0,'+(0.4+0.3*Math.sin(t*8))+')'; this.ctx.fillRect(x,0,this.tileSize,this.canvas.height); this.ctx.fillStyle='rgba(255,255,255,'+alpha+')'; this.ctx.fillRect(x+this.tileSize*0.4,0,this.tileSize*0.2,this.canvas.height);} } else if(e.kind==='explosion'){ const p=t; const maxR=this.tileSize*2.2; const r=maxR*p; this.ctx.globalCompositeOperation='lighter'; const cx=e.x*this.tileSize+this.tileSize/2; const cy=e.y*this.tileSize+this.tileSize/2; const g=this.ctx.createRadialGradient(cx,cy,0,cx,cy,r); g.addColorStop(0,'rgba(255,255,255,'+(1-p)+')'); g.addColorStop(.3,'rgba(255,200,0,'+(0.8*(1-p))+')'); g.addColorStop(1,'rgba(255,80,0,0)'); this.ctx.fillStyle=g; this.ctx.beginPath(); this.ctx.arc(cx,cy,r,0,Math.PI*2); this.ctx.fill(); } else { const pulse=(Math.sin(t*10)+1)/2; this.ctx.globalAlpha=1-t; if(e.orientation==='h'){ const y=e.index*this.tileSize; this.ctx.fillStyle='rgba(255,255,0,'+(0.25+0.25*pulse)+')'; this.ctx.fillRect(0,y,this.canvas.width,this.tileSize);} else { const x=e.index*this.tileSize; this.ctx.fillStyle='rgba(255,255,0,'+(0.25+0.25*pulse)+')'; this.ctx.fillRect(x,0,this.tileSize,this.canvas.height);} } this.ctx.restore(); });
            requestAnimationFrame(()=>this.render()); }

        // ====== 以下为之前版本中遗漏的核心方法，补回 ======
        ensureAudioUnlock(){ 
            if(this.audioUnlocked) return;
            
            // 立即尝试解锁音频，不等待用户交互
            const tryUnlock = () => {
                let unlockPromises = [];
                ['bg','pop','combo','win','lose'].forEach(k => {
                    const el = this.audio[k];
                    if(!el) return;
                    try {
                        const originalVolume = el.volume;
                        const originalMuted = el.muted;
                        
                        // 尝试静音播放来解锁音频上下文
                        el.volume = 0.001;
                        el.muted = true;
                        
                        const playPromise = el.play();
                        if(playPromise && playPromise.then) {
                            unlockPromises.push(
                                playPromise.then(() => {
                                    el.pause();
                                    el.currentTime = 0;
                                    el.volume = originalVolume;
                                    el.muted = originalMuted;
                                }).catch(() => {
                                    el.volume = originalVolume;
                                    el.muted = originalMuted;
                                })
                            );
                        } else {
                            el.pause();
                            el.currentTime = 0;
                            el.volume = originalVolume;
                            el.muted = originalMuted;
                        }
                    } catch(e) {
                        // 忽略错误，继续尝试其他音频元素
                    }
                });
                
                // 当所有音频元素尝试完成后标记为已解锁
                Promise.allSettled(unlockPromises).then(() => {
                    this.audioUnlocked = true;
                    if(this.canvas) {
                        this.showTip('🎵 音频已就绪', this.canvas.width/2, 120);
                    }
                });
            };
            
            // 立即尝试解锁
            tryUnlock();
            
            // 如果立即解锁失败，注册用户交互事件作为后备方案
            const unlockOnInteraction = () => {
                ['click','touchstart','keydown'].forEach(ev => 
                    document.removeEventListener(ev, unlockOnInteraction)
                );
                if(!this.audioUnlocked) {
                    tryUnlock();
                }
            };
            ['click','touchstart','keydown'].forEach(ev => 
                document.addEventListener(ev, unlockOnInteraction, {once:true})
            );
        }
        addLineEffect(orientation,index,kind='lineClear'){ this.effects.push({orientation,index,progress:0,kind}); }
        drawIce(x,y){ const cx=x*this.tileSize, cy=y*this.tileSize, pad=6, size=this.tileSize-pad*2, r=size*0.18; this.ctx.save(); this.ctx.beginPath(); this.ctx.roundRect(cx+pad,cy+pad,size,size,r); const g=this.ctx.createLinearGradient(cx,cy,cx+this.tileSize,cy+this.tileSize); g.addColorStop(0,'rgba(173,216,230,0.85)'); g.addColorStop(.5,'rgba(135,206,250,0.95)'); g.addColorStop(1,'rgba(173,216,230,0.85)'); this.ctx.fillStyle=g; this.ctx.fill(); this.ctx.strokeStyle='rgba(70,130,180,0.95)'; this.ctx.lineWidth=3; this.ctx.stroke(); this.ctx.strokeStyle='rgba(255,255,255,0.75)'; this.ctx.lineWidth=2; const cX=cx+this.tileSize/2, cY=cy+this.tileSize/2, s=this.tileSize*0.28; this.ctx.beginPath(); this.ctx.moveTo(cX-s/2,cY); this.ctx.lineTo(cX+s/2,cY); this.ctx.moveTo(cX,cY-s/2); this.ctx.lineTo(cX,cY+s/2); this.ctx.moveTo(cX-s/3,cY-s/3); this.ctx.lineTo(cX+s/3,cY+s/3); this.ctx.moveTo(cX+s/3,cY-s/3); this.ctx.lineTo(cX-s/3,cY+s/3); this.ctx.stroke(); this.ctx.restore(); }
        updateUI(){const s=document.getElementById('score'), m=document.getElementById('moves'), c=document.getElementById('chainInfo'); if(s) s.textContent=this.score; if(m) m.textContent=this.levelId==='自由'?'∞':this.moves; if(c) c.textContent=this.currentChain>1? this.currentChain+'连 (x'+(1+(this.currentChain-1)*0.5).toFixed(1)+')':'-'; }
        showTip(text,x,y){ const layer=document.getElementById('tipLayer'); if(!layer) return; const d=document.createElement('div'); d.className='floating-tip'; d.textContent=text; d.style.left=x+'px'; d.style.top=y+'px'; layer.appendChild(d); setTimeout(()=>{ if(d.parentNode) d.parentNode.removeChild(d); },1400); }
        clearCells(cells,reason,base=50){ const uniq=new Set(); cells.forEach(c=>uniq.add(c.x+','+c.y)); let count=0; uniq.forEach(k=>{const [x,y]=k.split(',').map(Number); const cell=this.grid[y]&&this.grid[y][x]; if(!cell) return; if(cell.locked){ cell.locked=0; this.spawnParticles(x,y,cell); count++; return;} this.spawnParticles(x,y,cell); this.grid[y][x]=null; count++;}); this.score+=count*base; this.updateUI(); }
        cascade(chain){ // 下落并填充
            for(let x=0;x<this.gridCols;x++){
                for(let y=this.gridRows-1;y>=0;y--){
                    if(this.grid[y][x]==null){
                        for(let k=y-1;k>=0;k--){
                            if(this.grid[k][x]!=null){
                                this.grid[y][x]=this.grid[k][x];
                                this.grid[y][x].y=y;
                                this.grid[k][x]=null;
                                break;
                            }
                        }
                    }
                }
            }
            for(let y=0;y<this.gridRows;y++) for(let x=0;x<this.gridCols;x++) if(this.grid[y][x]==null) this.grid[y][x]={type:Math.floor(Math.random()*this.gemTypes),x,y,special:null};
            const newGroups=this.findMatches();
            if(newGroups.length>0){ setTimeout(()=>this.processMatches(newGroups,chain+1),220);} else { this.animating=false; setTimeout(()=>{this.currentChain=0; this.updateUI();},500); this.ensureMoves(); this.postMoveCheck(); }
        }
        hasPossibleMoves(){ const trySwap=(ax,ay,bx,by)=>{const A=this.grid[ay][ax]; const B=this.grid[by][bx]; if(!A||!B) return false; this.grid[ay][ax]=B; this.grid[by][bx]=A; const ok=this.findMatches().length>0; this.grid[ay][ax]=A; this.grid[by][bx]=B; return ok;}; for(let y=0;y<this.gridRows;y++) for(let x=0;x<this.gridCols;x++){ if(x+1<this.gridCols && trySwap(x,y,x+1,y)) return true; if(y+1<this.gridRows && trySwap(x,y,x,y+1)) return true;} return false; }
        shuffleBoard(){ const flat=[]; for(let y=0;y<this.gridRows;y++) for(let x=0;x<this.gridCols;x++) if(this.grid[y][x]) flat.push(this.grid[y][x]); let attempts=0; while(attempts<80){ for(let i=flat.length-1;i>0;i--){const j=(Math.random()*(i+1))|0; [flat[i],flat[j]]=[flat[j],flat[i]];} let idx=0; for(let y=0;y<this.gridRows;y++) for(let x=0;x<this.gridCols;x++){const g=flat[idx++]; g.x=x; g.y=y; this.grid[y][x]=g;} if(this.findMatches().length===0 && this.hasPossibleMoves()) return true; attempts++; } return false; }
        ensureMoves(){ if(!this.hasPossibleMoves()){ if(this.shuffleBoard()) this.showTip('🔁 自动洗牌',this.canvas.width/2,this.canvas.height/2); else this.showTip('⚠️ 洗牌失败',this.canvas.width/2,this.canvas.height/2);} }
        postMoveCheck(){ if(this.levelId!=='自由' && this.score>=this.targetScore){ this.levelWin(); } else if(this.moves<=0 && this.levelId!=='自由'){ this.levelFail(); } }
        levelWin(){ this.play('win',0.9); this.saveCompletedLevel(this.levelId); alert('关卡 '+this.levelId+' 完成! 分数:'+this.score); if(!this.unlockedLevels[this.levelId+1]){ this.unlockedLevels[this.levelId+1]=true; this.saveUnlocked(); } this.isPlaying=false; SimpleUI.showScreen('levelSelect'); }
        levelFail(){ this.play('lose',0.9); alert('关卡失败! 分数:'+this.score); this.isPlaying=false; SimpleUI.showScreen('levelSelect'); }
        // ====== 补回方法结束 ======
    }

    // ================== 初始化 ==================
    function initGame(){ 
        try{ 
            GameEngine=new SimpleGameEngine(); 
            const q=id=>document.getElementById(id); 
            
            q('startGameBtn').onclick=()=>{
                SimpleUI.startLevel(1);
            }; 
            q('levelSelectBtn').onclick=()=>SimpleUI.showScreen('levelSelect'); 
            q('freePlayBtn').onclick=()=>{
                SimpleUI.startLevel(0);
            }; 
            q('backToMenuBtn').onclick=()=>SimpleUI.showScreen('mainMenu'); 
            q('restartBtn').onclick=()=>GameEngine.startLevel(GameEngine.levelId==='自由'?0:GameEngine.levelId); 
            q('backToLevelSelectBtn').onclick=()=>SimpleUI.showScreen('levelSelect'); 
            q('muteBtn').onclick=()=>GameEngine.toggleMute(); 
            q('toolShuffle').onclick=()=>{
                if(GameEngine && GameEngine.isPlaying) {
                    if(GameEngine.shuffleBoard()) {
                        GameEngine.showTip('🔁 已洗牌', GameEngine.canvas.width/2, GameEngine.canvas.height/2);
                        GameEngine.render();
                    }
                }
            }; 
            q('toolColorBomb').onclick=()=>GameEngine.activateTool('color'); 
            let addMovesUsed = false;
            q('addMovesBtn').onclick=()=>{
                if(GameEngine && GameEngine.isPlaying && !addMovesUsed) {
                    const add = Math.floor(Math.random()*3)+3; // 3~5
                    GameEngine.moves += add;
                    GameEngine.updateUI();
                    GameEngine.showTip('步数+'+add, 120, 120);
                    addMovesUsed = true;
                    q('addMovesBtn').disabled = true;
                    q('addMovesBtn').style.opacity = '0.5';
                }
            };
            // 每次开始新关卡时重置加步数按钮
            const origStartLevel = GameEngine.startLevel.bind(GameEngine);
            GameEngine.startLevel = function(id) {
                addMovesUsed = false;
                const btn = document.getElementById('addMovesBtn');
                if(btn) {
                    btn.disabled = false;
                    btn.style.opacity = '1';
                }
                origStartLevel(id);
            };
            // 页面加载完成后立即尝试启动音频和音乐
            debugLog('游戏初始化完成 - 音效已自动加载');
            setTimeout(()=>{
                const d=q('debugInfo'); 
                if(d) d.style.display='none';
            },1200);
        } catch(e) {
            console.error(e); 
            showError('初始化失败:'+e.message);
        } 
    
    }
    window.addEventListener('error',e=>debugLog('脚本错误: '+e.message)); window.addEventListener('unhandledrejection',e=>debugLog('Promise错误: '+e.reason));

    if(document.readyState==='loading') document.addEventListener('DOMContentLoaded',initGame); else initGame();
    </script>
</body>
</html>
